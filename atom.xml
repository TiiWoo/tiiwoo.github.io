<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>TiiWoo's Blog</title>
        <link>https://tiiwoo.github.io/TiiWoo.github.io</link>
        <description>喜欢玩</description>
        <lastBuildDate>Sat, 06 Feb 2021 14:19:35 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Gridsome Feed Plugin</generator>
        <atom:link href="https://tiiwoo.github.io/TiiWoo.github.io/atom.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[P3368 【模板】树状数组 2]]></title>
            <link>https://tiiwoo.github.io/TiiWoo.github.io/posts/fenwick-tree-2/</link>
            <guid>https://tiiwoo.github.io/TiiWoo.github.io/posts/fenwick-tree-2/</guid>
            <pubDate>Sat, 06 Feb 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h3 id="题目">题目</h3>
<p>[^1]</p>
<h4 id="题目描述">题目描述</h4>
<p>如题，已知一个数列，你需要进行下面两种操作：</p>
<ol>
<li>将某区间每一个数数加上 $x$；</li>
<li>求出某一个数的值。<!--more-->
<h4 id="输入格式">输入格式</h4>
</li>
</ol>
<p>第一行包含两个整数 $N$、$M$，分别表示该数列数字的个数和操作的总个数。</p>
<p>第二行包含 $N$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。</p>
<p>接下来 $M$行每行包含 2 或 4 个整数，表示一个操作，具体如下：</p>
<p>操作 1： 格式：<code>1 x y k</code> 含义：将区间 $x,y$ 内每个数加上 $k$；</p>
<p>操作 2： 格式：<code>2 x</code> 含义：输出第 $x$ 个数的值。</p>
<h4 id="输出格式">输出格式</h4>
<p>输出包含若干行整数，即为所有操作 2 的结果。</p>
<h4 id="输入输出样例">输入输出样例</h4>
<p><strong>输入 #1</strong></p>
<pre><code class="language-text">5 5
1 5 4 2 3
1 2 4 2
2 3
1 1 5 -1
1 3 5 7
2 4</code></pre>
<p><strong>输出 #1</strong></p>
<pre><code class="language-text">6
10</code></pre>
<h4 id="说明提示">说明/提示</h4>
<h5 id="样例-1-解释：">样例 1 解释：</h5>
<p><img src="https://rmt.dogedoge.com/fetch/royce/storage/fenwick-tree-2/01.png?fmt=webp" alt="解释"></p>
<p>故输出结果为 6、10。</p>
<hr>
<h5 id="数据规模与约定">数据规模与约定</h5>
<p>对于 $30%$ 的数据：$N\le8,M\le10$；</p>
<p>对于 $70%$ 的数据：$N\le 10000,M\le10000$；</p>
<p>对于 $100%$ 的数据：$1 \leq N, M\le 500000$，$1 \leq x, y \leq n$，保证任意时刻序列中任意元素的绝对值都不大于 $2^{30}$。</p>
<h3 id="题解">题解</h3>
<p>上一篇文章已经讲了<code>树状数组 1</code>，单点修改区间查询。</p>
<p>树状数组 2 需要实现的是区间修改，单点查询。</p>
<p>并且树状数组 2 要完全依赖于树状数组 1，仅在 1 的基础上引入差分数组</p>
<p>通过差分数组将其转换为单点修改区间查询，没错，就是树状数组 1，的单点修改区间查询</p>
<h4 id="前置知识-差分数组">前置知识 差分数组</h4>
<p>现有一序列 $A$
$$
A={3,,1,,4,,1,,5,,9,,2,,6,,5}
$$
建立一个差分数组 $D$, 使得 $D_i=A_i-A_{i-1}$
$$
D={3,;-2,,3,,-3,,4,,4,,-7,,4,,-1}
$$</p>
<p>此时将 $A$ 序列中 $A_3 \sim A_5$ 都加上 3，得到新的 $A$
$$
A={3,,1,,7,,4,,8,,9,,2,,6,,5}
$$
此时再更新 $D$ 数组
$$
D={3,,-2,,6,,-3,,4,,1,,-7,,4,,-1}
$$
不难发现，在 $A$ 序列的 $A_i \sim A_j$ 区间分别加上 $n$ ，在差分数组 $D$ 中就相当于 $D_i;+=; n,;D_{j+1};-=;n$</p>
<p>相信聪明的你已经发现了，这里出现了树状数组 1的单点修改</p>
<h4 id="查询">查询</h4>
<p>这个也就变的很简单了，利用差分数组的性质，假设我们要求 $A_3$</p>
<p>那么</p>
<p>$$
A_3=D_1+D_2+D_3
$$
好啦，就是这么简单</p>
<h3 id="结束">结束</h3>
<p>附上 AC 代码</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;

int n,m,k,x,aa,l,r;
int a[500110],c[500110];

int read() {
    bool flag = 1;
    int x = 0;
    char ch = getchar();
    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) {if (ch == &#39;-&#39;) flag = 0; ch = getchar();}
    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) {x *= 10;x += ch-&#39;0&#39;;ch=getchar();}
    return flag ? x:-x;
}
int lowbit(int x) {
    return x &amp; -x;
}
void add(int x,int k) {
    while (x&lt;=n) {
        c[x] += k;
        x += lowbit(x);
    }
}
int find(int x) {
    int sum = 0;
    while (x) {
        sum += c[x];
        x -= lowbit(x);
    }
    return sum;
}

int main() {
    n = read(); m = read();
    for (int i=1; i&lt;=n; i++) {
        a[i] = read();
        add(i, a[i]-a[i-1]);
    }
    while (m--) {
        aa = read();
        if (aa==1) {
            l = read(); r = read(); k =read();
            add(l,k);
            add(r+1,-k);
        }
        else {
            k = read();
            printf(&quot;%d\n&quot;, find(k));
        }
    }
    return 0;
}</code></pre>
<p>[^1]: 题目来源：<a href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】树状数组 2 - 洛谷 | 计算机科学教育新生态</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hello World]]></title>
            <link>https://tiiwoo.github.io/TiiWoo.github.io/posts/hello-world/</link>
            <guid>https://tiiwoo.github.io/TiiWoo.github.io/posts/hello-world/</guid>
            <pubDate>Sat, 06 Feb 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>我的博客诞生了！</p>
<p>$1+1=2$
$$
Hello; World
$$</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() 
{
    cout &lt;&lt; &quot;你好世界&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;
    return 0;
}</code></pre>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[P3372 【模板】线段树 1]]></title>
            <link>https://tiiwoo.github.io/TiiWoo.github.io/posts/segment-tree-1/</link>
            <guid>https://tiiwoo.github.io/TiiWoo.github.io/posts/segment-tree-1/</guid>
            <pubDate>Sat, 06 Feb 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="题目">题目</h2>
<h3 id="题目描述">题目描述</h3>
<p>如题，已知一个数列，你需要进行下面两种操作：</p>
<ol>
<li>将某区间每一个数加上 $k$。</li>
<li>求出某区间每一个数的和。</li>
</ol>
<h3 id="输入格式">输入格式</h3>
<p>第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。</p>
<p>第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。</p>
<p>接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：</p>
<ol>
<li><code>1 x y k</code>：将区间 $[x, y]$ 内每个数加上 $k$。</li>
<li><code>2 x y</code>：输出区间 $[x,y]$ 内每个数的和。</li>
</ol>
<h3 id="输出格式">输出格式</h3>
<p>输出包含若干行整数，即为所有操作 2 的结果。</p>
<h3 id="输入输出样例">输入输出样例</h3>
<p><strong>输入 #1</strong></p>
<pre><code class="language-text">5 5
1 5 4 2 3
2 2 4
1 2 3 2
2 3 4
1 1 5 1
2 1 4</code></pre>
<p><strong>输出 #1</strong></p>
<pre><code class="language-text">11
8
20</code></pre>
<h3 id="说明提示">说明/提示</h3>
<p>对于 $30%$ 的数据：$n \le 8$，$m \le 10$。<br>对于 $70%$ 的数据：$n \le {10}^3$，$m \le {10}^4$。<br>对于 $100%$ 的数据：$1 \le n, m \le {10}^5$。</p>
<p>保证任意时刻数列中任意元素的和在 $[-2^{63}, 2^{63})$ 内。</p>
<p><strong>【样例解释】</strong></p>
<p><img src="https://rmt.dogedoge.com/fetch/royce/storage/2024/01.png?fmt=webp" alt="样例解释"></p>
<h2 id="题解">题解</h2>
<p>:::tip
想认真学推荐看看这篇两篇</p>
<p><a href="https://www.cnblogs.com/TheRoadToTheGold/p/6254255.html">浅谈线段树 - TRTTG - 博客园</a>
<a href="https://oi-wiki.org/ds/seg/">线段树 - OI Wiki</a>
:::</p>
<h3 id="建树">建树</h3>
<p>一直二分，直到 到了叶子节点，输入数据，==记住 return==</p>
<p>非叶子节点的值为 左儿子+右儿子</p>
<pre><code class="language-cpp">// 建树，k 当前节点
void build(LL l, LL r, LL k) {
    LL mid = (l + r) / 2;
    tree[k].l = l, tree[k].r = r;
    if (l == r) { // 判断叶子节点
        tree[k].w = read();
        return;
    }
    build(l, mid, 2*k);
    build(mid+1, r, 2*k+1);
    tree[k].w = tree[2*k].w + tree[2*k+1].w;
}</code></pre>
<h3 id="懒标记">懒标记</h3>
<blockquote>
<p>A 有两个儿子，一个是 B，一个是 C。</p>
<p>有一天 A 要建一个新房子，没钱。刚好过年嘛，有人要给 B 和 C 红包，两个红包的钱数相同都是 $1$ 元，然而因为 A 是父亲所以红包肯定是先塞给 A 咯~</p>
<p>理论上来讲 A 应该把两个红包分别给 B 和 C，但是……缺钱嘛，A 就把红包偷偷收到自己口袋里了。</p>
<p>A 高兴地说：「我现在有 $2$ 份红包了！我又多了 $2 \times 1 = 2$ 元了！哈哈哈~」</p>
<p>但是 A 知道，如果他不把红包给 B 和 C，那 B 和 C 肯定会不爽然后导致家庭矛盾最后崩溃，所以 A 对儿子 B 和 C 说：「我欠你们每人 $1$ 份 $1$ 元的红包，下次有新红包给过来的时候再给你们！这里我先做下记录……嗯……我欠你们各 $1$ 元……」</p>
<p>儿子 B、C 有点恼怒：「可是如果有同学问起我们我们收到了多少红包咋办？你把我们的红包都收了，我们还怎么装？」</p>
<p>父亲 A 赶忙说：「有同学问起来我就会给你们的！我欠条都写好了不会不算话的！」</p>
<p>这样 B、C 才放了心。[^2]</p>
</blockquote>
<p>举个例子：</p>
<p>要求 $4 \backsim 5$ 的数都加上 $2$</p>
<p>那么我们现在只需要将其父亲节点 $2$ 的懒标记 $+2$</p>
<p>需要用到的时候将懒标记下传给子节点</p>
<p>下传操作：</p>
<ol>
<li><p>两个子节点的懒标记分别加上父亲节点的懒标记的值</p>
</li>
<li><p>子节点的值分别加上 $(r-l+1) \times$ 父亲节点的懒标记值。$(r-l+1)$ 表示该节点之下还有多少节点，这里必须乘父亲节的懒标记的值，而不是自己的懒标记，因为自身的懒标记可能还包含上一次下传的值</p>
</li>
<li><p>父亲节点懒标记归零</p>
</li>
</ol>
<pre><code class="language-cpp">// 懒标记下传，k 当前节点
void down(LL k) {
    tree[k * 2].f += tree[k].f;
    tree[k*2 + 1].f += tree[k].f;

    tree[k * 2].w += tree[k].f * (tree[k*2].r - tree[k*2].l + 1);
    tree[k*2 + 1].w += tree[k].f * (tree[k*2+1].r - tree[k*2+1].l + 1);

    tree[k].f = 0;
}</code></pre>
<h3 id="区间修改">区间修改</h3>
<p>$n = [l, r]$ 需要修改的区间，$m = [s, t]$ 当前区间</p>
<p>$n, m$ 只满足以下三种关系的一种</p>
<ol>
<li>$m \subseteq n$</li>
<li>$m \cap n$ 不为空</li>
<li>$n \subseteq m$</li>
</ol>
<h4 id="1">1</h4>
<p>第一种情况 $m \subseteq n$，直接返回当前区间 $m$ 的值就行了</p>
<h4 id="2">2</h4>
<p>第二种情况 $m \cap n$ 不为空</p>
<p>令 $mid= \frac{s+t}{2}$</p>
<ol>
<li>$l \le mid$ 则说明待修改区间（一部分）在当前节点的左孩子</li>
<li>$r &gt; mid$ 则说明待修改区间（一部分）在当前节点的右孩子</li>
</ol>
<p>重复多次后就得到了情况 1
（画个图模拟下就明白了）</p>
<h4 id="3">3</h4>
<p>第三种情况 $n \subseteq m$</p>
<p>解决方法和情况 2 相同</p>
<pre><code class="language-cpp">// 区间修改 [l, r] 修改区间，[s, t]当前区间，k 当前节点，addition 修改的值
void update(LL l, LL r, LL k, LL addition) {
    LL s = tree[k].l, t = tree[k].r;
    LL mid = (s + t) / 2;

    if(l&lt;=s &amp;&amp; t&lt;=r) {
        tree[k].f += addition;
        tree[k].w += addition * (t - s + 1);
        return;
    }

    // 不满足上面的 if，所以需要修改子节点，所以需要下传懒标记
    if(tree[k].f) down(k);
    if(l &lt;= mid) update(l, r, k*2, addition);
    if(r &gt; mid) update(l, r, 2*k+1, addition);
    tree[k].w = tree[2*k].w + tree[2*k+1].w;
}</code></pre>
<h3 id="区间查询">区间查询</h3>
<p>与区间修改基本一样</p>
<p>$n = [l, r]$ 需要查询的区间，$m = [s, t]$ 当前区间</p>
<p>$n, m$ 只满足以下三种关系的一种</p>
<ol>
<li>$m \subseteq n$</li>
<li>$m \cap n$ 不为空</li>
<li>$n \subseteq m$</li>
</ol>
<pre><code class="language-cpp">// 区间查询，[l, r] 查询区间，[s, t]当前区间，k 当前节点
LL getsum(LL l, LL r, LL k) {
    LL s = tree[k].l, t = tree[k].r;
    LL mid = (s + t) / 2, sum = 0;

    // 不满足上面的 if，所以需要修改子节点，所以需要下传懒标记
    if(l&lt;=s &amp;&amp; t&lt;=r) return tree[k].w;

    if(tree[k].f) down(k);
    if(l &lt;= mid) sum += getsum(l, r, k*2);
    if(r &gt; mid) sum += getsum(l, r, 2*k+1);
    return sum;
}</code></pre>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#define LL long long

LL n, m;
struct node {
    LL l, r, w, f; // w 值，f 懒标记
}tree[400001]; // 大小 4 * n

LL read() {
    bool flag = 0; LL x = 0; char ch = getchar();
    while(ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) {if (ch == &#39;-&#39;) flag = 1; ch = getchar();}
    while(ch&gt;=&#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) {x *= 10; x += ch - &#39;0&#39;; ch = getchar();}
    return flag ? - x : x;
}

// 建树，k 当前节点
void build(LL l, LL r, LL k) {
    LL mid = (l + r) / 2;
    tree[k].l = l, tree[k].r = r;
    if (l == r) { // 判断叶子节点
        tree[k].w = read();
        return;
    }
    build(l, mid, 2*k);
    build(mid+1, r, 2*k+1);
    tree[k].w = tree[2*k].w + tree[2*k+1].w;
}

// 懒标记下传，k 当前节点
void down(LL k) {
    tree[k * 2].f += tree[k].f;
    tree[k * 2].w += tree[k].f * (tree[k*2].r - tree[k*2].l + 1);
    tree[k*2 + 1].f += tree[k].f;
    tree[k*2 + 1].w += tree[k].f * (tree[k*2+1].r - tree[k*2+1].l + 1);
    tree[k].f = 0;
}

// 单点修改，k 当前节点
void add(LL k, LL addition) {
    LL l = tree[k].l, r = tree[k].r;
    LL mid = (l + r) / 2;

    if (l == r) {
        tree[k].w += addition;
        return;
    }

    // 不满足上面的 if，所以需要修改子节点，所以需要下传懒标记
    if (tree[k].f) down(k);

    if (x &lt;= mid) add(2 * k);
    else add(2*k + 1);
    tree[k].w = tree[2*k].w + tree[2*k+1].w;
}

// 单点查询，k 当前节点
LL ask(LL k) {
    LL l = tree[k].l, r = tree[k].r;
    LL mid = (l + r) / 2;

    // 不满足上面的 if，所以需要修改子节点，所以需要下传懒标记
    if (l == r) return tree[k].w;

    if (x &lt;= mid) ask[2 * k];
    else ask(2*k + 1)
}

// 区间修改 [l, r] 修改区间，[s, t]当前区间，k 当前节点，addition 修改的值
void update(LL l, LL r, LL k, LL addition) {
    LL s = tree[k].l, t = tree[k].r;
    LL mid = (s + t) / 2;

    if(l&lt;=s &amp;&amp; t&lt;=r) {
        tree[k].f += addition;
        tree[k].w += addition * (t - s + 1);
        return;
    }

    // 不满足上面的 if，所以需要修改子节点，所以需要下传懒标记
    if(tree[k].f) down(k);
    if(l &lt;= mid) update(l, r, k*2, addition);
    if(r &gt; mid) update(l, r, 2*k+1, addition);
    tree[k].w = tree[2*k].w + tree[2*k+1].w;
}

// 区间查询，[l, r] 查询区间，[s, t]当前区间，k 当前节点
LL getsum(LL l, LL r, LL k) {
    LL s = tree[k].l, t = tree[k].r;
    LL mid = (s + t) / 2, sum = 0;

    // 不满足上面的 if，所以需要修改子节点，所以需要下传懒标记
    if(l&lt;=s &amp;&amp; t&lt;=r) return tree[k].w;

    if(tree[k].f) down(k);
    if(l &lt;= mid) sum += getsum(l, r, k*2);
    if(r &gt; mid) sum += getsum(l, r, 2*k+1);
    return sum;
}

int main() {
    n = read(), m = read();
    build(1, n, 1);

    while (m--) {
        LL t = read(), x = read(), y = read();
        if (t == 2)
            printf(&quot;%lld\n&quot;, getsum(x, y, 1, n, 1));
        else {
            LL k = read();
            update(x, y, 1, n, 1, k);
        }
    }
    return 0;
}</code></pre>
<p>学完可以做做 <a href="https://www.luogu.com.cn/problem/P2068">P2068 统计和</a></p>
<p>[^1]: 题目来源 <a href="https://www.luogu.com.cn/problem/P3372">【模板】线段树 1 - 洛谷</a>
[^2]: 来自 <a href="https://oi-wiki.org/ds/seg/#_4">线段树 - OI Wiki</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[P3368 【模板】树状数组 1]]></title>
            <link>https://tiiwoo.github.io/TiiWoo.github.io/posts/fenwick-tree-1/</link>
            <guid>https://tiiwoo.github.io/TiiWoo.github.io/posts/fenwick-tree-1/</guid>
            <pubDate>Sat, 06 Feb 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="题目">题目</h2>
<p>[^1]</p>
<h4 id="题目描述">题目描述</h4>
<p>如题，已知一个数列，你需要进行下面两种操作：</p>
<ul>
<li>将某一个数加上 $x$</li>
<li>求出某区间每一个数的和</li>
</ul>
<!--more-->

<h4 id="输入格式">输入格式</h4>
<p>第一行包含两个正整数 $n,m$，分别表示该数列数字的个数和操作的总个数。</p>
<p>第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。</p>
<p>接下来 $m$ 行每行包含 33 个整数，表示一个操作，具体如下：</p>
<ul>
<li><code>1 x k</code> 含义：将第 $x$ 个数加上 $k$</li>
<li><code>2 x y</code> 含义：输出区间 $[x,y]$ 内每个数的和</li>
</ul>
<h4 id="输出格式">输出格式</h4>
<p>输出包含若干行整数，即为所有操作 22 的结果。</p>
<h4 id="输入输出样例">输入输出样例</h4>
<p><strong>输入 #1</strong></p>
<pre><code class="language-text">5 5
1 5 4 2 3
1 1 3
2 2 5
1 3 -1
1 4 2
2 1 4</code></pre>
<p><strong>输出 #1</strong></p>
<pre><code class="language-text">14
16</code></pre>
<h4 id="说明提示">说明/提示</h4>
<p>【数据范围】</p>
<p>对于 $30%$ 的数据，$1 \le n \le 8，1\le m \le 10$；</p>
<p>对于 $70%$ 的数据，$1\le n,,m\le10^4;$</p>
<p>对于 $100%$ 的数据，$1\le n,m \le 5\times 10^5$。</p>
<p>样例说明：</p>
<p>故输出结果 14、16</p>
<p><img src="https://gitee.com/royce2003/blog/raw/master/img/2256.png" alt="数据范围"></p>
<p>(写这篇呢其实是因为自己已经不会树状数组了，正好借此机会复习下 QAQ)</p>
<h2 id="题解">题解</h2>
<h3 id="树状数组">树状数组</h3>
<p>首先需要了解什么是 <code>树状数组</code></p>
<p>树状数组用的是树结构的思想，即树型逻辑结构，但他不是树形结构啦</p>
<h4 id="特点">特点</h4>
<blockquote>
<p>树状数组 (Binary Indexed Tree(B.I.T), Fenwick Tree)是一个查询和修改复杂度都为 og(n) 的数据结构。主要用于查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值；经过简单修改可以在 log(n) 的复杂度下进行范围修改，但是这时只能查询其中一个元素的值(如果加入多个辅助数组则可以实现区间修改与区间查询)。</p>
</blockquote>
<p>对于这题，简单来说就是单点修改区间查询，一般地，树状数组不支持区间修改单点差选，但是我们也有办法让他支持.....</p>
<p>树状数组的优势就在于其维护的时间复杂度为 $O(log , n)$ ，而类似的前缀和数组维护的时间复杂度为 $O(n)$，两者的查询都是 $O(1)$</p>
<p>（说到这我就想起来某次校内赛的xzt买煎饼。。。。还好我拿了20分）</p>
<h3 id="前置知识">前置知识</h3>
<h4 id="lowbit">lowbit</h4>
<p>实际上，对于树状数组 $tree$ 的每一个 $i$，其实际意义应该为：算上其本身的讯息，总共存储了 $2^k$ 个元素的信息，其中 $k$ 表示 $i$ 在二进制下，末尾零的个数，同时也可以表示最小的含 1 位的二进制权值——换句话讲，$2^k$ 即可表示成：对于每个二进制意义下的 $i$，从最末位数 $k+1$ 位，保留这 $k+1$ 位并删除 $k+1$ 位以左的所有数位上的数，留下的新二进制数的实际大</p>
<p><img src="https://gitee.com/royce2003/blog/raw/master/img/0dd7912397dda14482d369acbfb7d0a20df486d1.jpg" alt="树状数组结构"></p>
<table>
<thead>
<tr>
<th align="center">十进制</th>
<th align="center">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">11</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">101</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">110</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">111</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">1000</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">1001</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">1010</td>
</tr>
</tbody></table>
<p>图文并茂之后有没有看出点什么 QAQ</p>
<p>记得当时学的时候，在学校大佬的帮助下才理解了这些东西，可能我比较菜吧</p>
<p><del>没看出来就多看几遍吧</del> 好像也还是看不出来，那就记下来结论吧</p>
<p>对于每一个 $x$ 的最低含一位，即上文中的 $2^k$,可以借助一个 $lowbit$ 函数实现 emmm 一个极其玄学的东西</p>
<p>再把 <code>lowbit</code> 说简单点就是</p>
<p>把一个整数变成二进制，从右往左找到第一个1，然后返回这个1所表示的十进制值。</p>
<p>玄学公式登场 <code>x &amp; -x</code></p>
<p>举个例子</p>
<p>$$
4 = 100,,-4 = 011 + 1 = 100\
~\
\because100,&amp;,100=100=4 \
 ~\
\therefore lowbit(4)=4\
$$</p>
<pre><code class="language-cpp">int lowbit(int x) {
    return x &amp; -x; //就是这么玄学
}</code></pre>
<p>为什么要这样干呢</p>
<p>我们先列出 1~8 的 $lowbit$</p>
<p>$1;2;1;4;1;2;1;8$</p>
<p>我们让 $C[i]$ 管理 $A[i-lowbit(i)+1,,i]$ 这段区间，如下图</p>
<p><img src="https://gitee.com/royce2003/blog/raw/master/img/Snipaste_03-19_11-45-31.png" alt="对应管理"></p>
<p>那么我们把某个点 $+x$ 的时候只需要把能管到这个点的都 $+x$ 就好啦，那我们如何找哪些能管到我们修改的点呢，这时候就需要 $lowbit$ 了</p>
<h4 id="前缀和">前缀和</h4>
<h5 id="一维前缀和">一维前缀和</h5>
<p>现有一个长度为 $N$ 的序列 $A$，需要进行 $M$ 次操作，每次操作选取从 $A_i$ 到 $A_j$ 共 $j-i+1$ 个数并求出他们的总和 （N 和 M 可以很大）  </p>
<p>例：</p>
<p>$$
N=9,;A={3,1,4,1,5,9,2,6,5}
$$</p>
<p>如果按照题意暴力，最坏情况下时间复杂度 $O(n\times m)$（是这个吗，我咋感觉时间复杂度好像大概可能不是这个QAQ）</p>
<p>反正时间复杂度挺高的就对了</p>
<p>那我们可以新建一个数组 $B$ ，其中 $B_i=B_{i-1} +A_i$</p>
<p>此时我们需要求 $a_i-a_j$ 的总和，<del>意会下</del>，只需要求 $B_j-B_{i-1}$ 就好啦</p>
<p><del>很明显</del>，利用前缀和的方法，因为B数组是在读入时进行处理，可以看作不需要时间，而查询的时间复杂度就是 $O(1)$ 啦</p>
<h5 id="二维前缀和">二维前缀和</h5>
<p>一维前缀和会了二维的也很简单</p>
<p>$$
A=
\left[
\begin{matrix}
5 &amp; 6 &amp; 6 &amp; 1 &amp; 4 &amp; 6\
3 &amp; 4 &amp; 2 &amp; 4 &amp; 1 &amp; 7 \
0 &amp; 9 &amp; 4 &amp; 6 &amp; 2 &amp; 4
\end{matrix}
\right]
;
B=
\left[
\begin{matrix}
5 &amp; 11 &amp; 17 &amp; 18 &amp; 21 &amp; 27\
8 &amp; 18 &amp; 26 &amp; \cdots &amp; \cdots &amp; \cdots \
\cdots &amp; \cdots &amp; \cdots &amp; \cdots  &amp; \cdots &amp; \cdots
\end{matrix}
\right]
$$</p>
<p>若我们要求 $x_1,,y_1$ 与 $x_2,,y_2$ 两点所围成矩形内数字的和
公式 $sum=B_{x_2,y_2}-B_{x_2,1}-B_{1,y_1}+B_{x_1-1,y_1-1}$</p>
<h3 id="储存">储存</h3>
<p>树状数组本质就是一个数组，我们用 C 来表示，然后把 C 排成数🎄的样子，就像前面的那个图那样</p>
<p><img src="https://gitee.com/royce2003/blog/raw/master/img/0dd7912397dda14482d369acbfb7d0a20df486d1.jpg" alt="树状数组结构"></p>
<p>$C[1]=A[1]$<br>$C[2]=A[1]+A[2]$<br>$C[3]=A[3]$<br>$C[4]=A[1]+A[2]+A[3]+A[4]$<br>$C[5]=A[5]$<br>$C[6]=A[5]+A[6]$<br>$C[7]=A[7]$<br>$C[8]=A[1]+A[2] \cdots A[8]$</p>
<p>很明显 $C[i]=A[i-lowbit(i)+1]+A[i-lowbit(i)+2]+ \cdots +A[i]$</p>
<p>用代码写就是</p>
<pre><code class="language-cpp">for (j=i-lowbit(i)+1; j&lt;= i; j++)
    c[i] += a[j];</code></pre>
<p>对于 1, 3, 5, 7 这类 $C[i]$ 后只有一个 $A[i]$ 的，我们称之为基点<br>不难发现基点的都是是奇数，即 lowbit=1
反之，lowbit=1 的数一定是奇数，也一定是基点。</p>
<p>而对于 1, 2, 4, 8 这类 $C[i]$ 后是 $\sum_{x=1}^i a_x$ 的，我们称之为统括点<br>也不难发现，统括点的二进制能写成 1000…… 的形式
那么统括点一定就是 2 的幂，反之 2 的幂也一定是统括点</p>
<p>特别的，1 既是基点又是统括点<br>6 不是基点也不是统括点</p>
<h3 id="单点修改">单点修改</h3>
<p>如何进行单点修改，其实在之前已经讲过了<br>比如我们让 $A[3]+1$，那么有包含 $A[3]$ 的所有 $C$ 都要 $+1$
包括 $C[3],C[4],C[8],C[16],C[32]\cdots$</p>
<p>那么我们只需要这样就行了</p>
<pre><code class="language-cpp">for(j=i; j&lt;=n; j+=lowbit(j))
    C[i] += x;</code></pre>
<h3 id="区间查询">区间查询</h3>
<p>要想得到 i 到 j 的所有数的总和 $sum_{i,j}$，只需要得到 $sum_{1,i}$ 和 $sum_{1,j}$</p>
<p>$$
sum_{i,j} = sum_{1,i} - sum_{1,j} + A_i
$$</p>
<p>也就是前面讲到的前缀和</p>
<p>先求 $sum_{1,i}$ ，即从 i 开始不断减去 lowbit 并加 C 的值，直到找到第一个统括点（第一个包含该点的统括点）</p>
<pre><code class="language-cpp">int find(int x) {
    int sum = 0,i;
    for(i=x; i!=lowbit(i); i-=lowbit(i))
        sum += c[i];
    sum += c[i]; //因为最后一次循环并没有进入，故在此处再加一次c[i]
    return sum;
}</code></pre>
<p>$sum_{1,j}$ 同理</p>
<h3 id="结束">结束</h3>
<p>附上 AC 代码</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

int n,m,k,x,aa;
int a,c[500110];

int lowbit(int x) {
    return x &amp; -x;
}
void add(int x,int k) {
    while(x&lt;=n) {
        c[x] += k;
        x += lowbit(x);
    }
}
int find(int x) {
    int sum = 0,i;
    for(i=x;i!=lowbit(i);i-=lowbit(i))
        sum += c[i];
    sum += c[i];
    return sum;
}

int main() {ssd
    cin &gt;&gt; n &gt;&gt; m;
    for(int i=1;i&lt;=n;i++) {
        cin &gt;&gt; a;
        add(i,a);
    }
    while(m--) {
        cin &gt;&gt; aa &gt;&gt; x &gt;&gt; k;
        if(aa==1) add(x,k);
        else cout &lt;&lt; find(k) - find(x-1) &lt;&lt; endl; //此处和 find(k) - find(x) + a[x] 是一样的
    }
    return 0;
}</code></pre>
<p>[^1]: 题目来源：<a href="https://www.luogu.com.cn/problem/P3374">P3374 - 洛谷 | 计算机科学教育新生态</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[P3372 【模板】线段树 2]]></title>
            <link>https://tiiwoo.github.io/TiiWoo.github.io/posts/segment-tree-2/</link>
            <guid>https://tiiwoo.github.io/TiiWoo.github.io/posts/segment-tree-2/</guid>
            <pubDate>Sat, 06 Feb 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>[^1]</p>
<h2 id="题目描述">题目描述</h2>
<p>如题，已知一个数列，你需要进行下面三种操作：</p>
<ul>
<li>将某区间每一个数乘上 $x$</li>
<li>将某区间每一个数加上 $x$</li>
<li>求出某区间每一个数的和</li>
</ul>
<h2 id="输入格式">输入格式</h2>
<p>第一行包含三个整数 n,m,p，分别表示该数列数字的个数、操作的总个数和模数。</p>
<p>第二行包含 n 个用空格分隔的整数，其中第 i 个数字表示数列第 i 项的初始值。</p>
<p>接下来 m 行每行包含若干个整数，表示一个操作，具体如下：</p>
<p>操作 $1$： 格式：<code>1 x y k</code> 含义：将区间 $[x,y]$ 内每个数乘上 $k$</p>
<p>操作 $2$： 格式：<code>2 x y k</code> 含义：将区间 $[x,y]$ 内每个数加上 $k$</p>
<p>操作 $3$： 格式：<code>3 x y</code> 含义：输出区间 $[x,y]$ 内每个数的和对 $p$ 取模所得的结果</p>
<h2 id="输出格式">输出格式</h2>
<p>输出包含若干行整数，即为所有操作 $3$ 的结果。</p>
<h2 id="输入输出样例">输入输出样例</h2>
<p><strong>输入 #1</strong></p>
<pre><code class="language-text">5 5 38
1 5 4 2 3
2 1 4 1
3 2 5
1 2 4 2
2 3 5 5
3 1 4</code></pre>
<p><strong>输出 #1</strong></p>
<pre><code class="language-text">17
2</code></pre>
<h2 id="说明提示">说明/提示</h2>
<p>【数据范围】</p>
<p>对于 $30%$ 的数据：$n \le 8$，$m \le 10$
对于 $70%$ 的数据：$n \le 10^3$，$m \le 10^4$
对于 $100%$ 的数据：$n \le 10^5$，$m \le 10^5$</p>
<p>除样例外，$p = 571373$</p>
<p>（数据已经过加强^_^）</p>
<p>样例说明：</p>
<p><img src="https://rmt.dogedoge.com/fetch/royce/storage/SegmentTree2/01.jpg?fmt=webp" alt="img"></p>
<p>故输出应为 $17$、$22(40 \bmod 38 = 2)$</p>
<h2 id="所以">所以</h2>
<p>真的有那么亿点点难理解，也还不怎么会，学的时候主要是看 <a href="https://oi-wiki.org/ds/seg/#luogu-p3373-2">线段树 - OI Wiki</a> 的代码 和 <a href="https://www.luogu.com.cn/blog/lhr/solution-p3373">题解 P3373 【【模板】线段树 2】 - lqhsr 的博客</a> 的思路</p>
<p>一个讲的挺明白的，一个代码看着挺明白的 :trophy:</p>
<h3 id="结构体函数">结构体函数</h3>
<p>之前学结构体的时候知道里面可以定义函数，也只是知道，从来没用过。
这题因为经常要 <code>mod</code>，配合结构体函数还是挺方便的。</p>
<pre><code class="language-cpp">struct Test {
    int test1, test2, test3;
    void mod() {
        test1 %= p;
        test2 %= p;
        test3 %= p;
    }
}test[100];

test[k].mod();</code></pre>
<h3 id="懒标记下传">懒标记下传</h3>
<p>和线段树 1 比，多了一个乘法，所以多了乘法懒标记，<strong>初值为 1</strong>。
乘法懒标记下传时需要对 <code>加法懒标记</code>、<code>乘法懒标记</code>和<code>值</code> 进行乘法。
区间乘法也同样的需要对这三个值进行乘法。
其他的基本和线段树 1 一样。</p>
<p>懒标记下传的代码确实挺长的，但理清思路发现还是比较好理解的。</p>
<ol>
<li>乘法懒标记不为 1，则需要下传。
分左右儿子，每边先把所有的乘法做好，再 <code>.mod()</code></li>
</ol>
<p><strong>最后父亲乘法懒标记赋值为 1</strong></p>
<ol start="2">
<li>加法懒标记不为 0，则需要下传。也分左右儿子
儿子懒标记加上父亲懒标记
儿子值加上 （父亲懒标记 * 儿子所办含的节点数）
再 <code>.mod()</code></li>
</ol>
<p><strong>最后父亲懒标记归零</strong></p>
<h3 id="区间修改">区间修改</h3>
<p>整体思路和线段树 1 的一样，乘法的区间修改唯一的区别就在最后一步</p>
<pre><code class="language-cpp">if (l&lt;=s &amp;&amp; t&lt;=r) {
    tree[k].m *= c;
    tree[k].f *= c;
    tree[k].w *= c;
    tree[k].mod();
    return;
}</code></pre>
<h3 id="完整代码">完整代码</h3>
<pre><code class="language-cpp">#include &lt;cstdio&gt;

long long n, m, d, x, y, at, c, p;
struct node {
    long long l, r, w, f, m;
    void mod() {
        w %= p;
        f %= p;
        m %= p;
    }
}tree[400010];

long long read() {
    bool flag = false; long long x = 0; char ch = getchar();
    while(ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) {if(ch == &#39;-&#39;) flag = 1; ch = getchar();}
    while(ch&gt;=&#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) {x *= 10; x += ch - &#39;0&#39;; ch = getchar();}
    return flag ? - x : x;
}

void build(long long l, long long r, long long k) {
    long long mid = (l + r) / 2;
    tree[k].l = l, tree[k].r = r, tree[k].m = 1;
    if (l == r) {
        tree[k].w = read();
        return;
    }
    build(l, mid, 2*k);
    build(mid+1, r, 2*k+1);
    tree[k].w = tree[2*k].w + tree[2*k+1].w;
    tree[k].mod();
}

void down(long long k) {
    long long lson = 2 * k, rson = 2 * k + 1;
    int m = tree[k].m, f = tree[k].f;
    if (tree[k].m != 1) {
        tree[lson].w *= m;
        tree[lson].f *= m;
        tree[lson].m *= m;
        tree[lson].mod();

        tree[rson].w *= m;
        tree[rson].f *= m;
        tree[rson].m *= m;
        tree[rson].mod();

        tree[k].m = 1;
    }
    if (f) {
        tree[lson].f += f;
        tree[lson].w += f * (tree[lson].r - tree[lson].l + 1);
        tree[lson].mod();

        tree[rson].f += f;
        tree[rson].w += f * (tree[rson].r - tree[rson].l + 1);
        tree[rson].mod();

        tree[k].f = 0;
    }
}

void cheng(long long l, long long r, long long k, long long c) {
    long long s = tree[k].l, t = tree[k].r;
    long long mid = (s + t) / 2;

    if (l&lt;=s &amp;&amp; t&lt;=r) {
        tree[k].m *= c;
        tree[k].f *= c;
        tree[k].w *= c;
        tree[k].mod();
        return;
    }

    down(k);
    if (l &lt;= mid) cheng(l, r, 2*k, c);
    if (r &gt;= mid + 1) cheng(l, r, 2*k+1, c);

    tree[k].w = tree[2*k].w + tree[2*k+1].w;
    tree[k].w %= p;
}

void add(long long l, long long r, long long k, long long at) {
    long long s = tree[k].l, t = tree[k].r;
    long long mid = (s + t) / 2;

    if (l&lt;=s &amp;&amp; t&lt;=r) {
        tree[k].f += at;
        tree[k].w += at * (t - s + 1);
        tree[k].mod();
        return;
    }

    down(k);
    if (l &lt;= mid) add(l, r, 2*k, at);
    if (r &gt;= mid + 1) add(l, r, 2*k+1, at);

    tree[k].w = tree[2*k].w + tree[2*k+1].w;
    tree[k].mod();
}

long long get(long long l, long long r, long long k) {
    long long s = tree[k].l, t = tree[k].r, sum = 0;
    long long mid = (s + t) / 2;

    if (l&lt;=s &amp;&amp; t&lt;=r) {
        return tree[k].w;
    }

    down(k);
    if (l &lt;= mid) sum += get(l, r, 2*k);
    sum %= p;
    if (r &gt;= mid + 1) sum += get(l, r, 2*k+1);
    return sum % p;
}

int main() {
    n = read(), m = read(), p = read();
    build(1, n, 1);

    while (m--) {
        d = read(), x = read(), y = read();
        if (d == 1) {
            c = read();
            cheng(x, y, 1, c);
        }
        else if (d == 2) {
            at = read();
            add(x, y, 1, at);
        }
        else printf(&quot;%lld\n&quot;, get(x, y, 1));
    }
    return 0;
}</code></pre>
<p>:::warning 🚨 注意 %}</p>
<p>mod 别忘了</p>
<p>add 要 return
cheng 要 return
build 要 return</p>
<p>get 要 down(k)
add 要 down(k)
cheng 要 down(k)</p>
<p>:::</p>
<p>[^0]: Banner from <a href="https://icons8.com/">Icons8</a>
[^1]: 题目来源 <a href="https://www.luogu.com.cn/problem/P3373">【模板】线段树 2 - 洛谷</a></p>
]]></content:encoded>
        </item>
    </channel>
</rss>